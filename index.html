<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solana Wallet Toolkit</title>
    <style>
        /* Dark mode elegant styling with teal accents */
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            max-width: 1200px;
            width: 100%;
        }
        .panel {
            background-color: #1e1e1e;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        h2 {
            color: #00b4d8; /* Teal */
        }
        button {
            background-color: #00b4d8;
            color: #121212;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #48cae4;
        }
        input, select {
            background-color: #2c2c2c;
            color: #ffffff;
            border: 1px solid #00b4d8;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            width: 100%;
        }
        #logs {
            background-color: #000000;
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .hidden {
            display: none;
        }
        .address {
            cursor: pointer;
            color: #00b4d8;
        }
        .loading {
            color: #ffd166;
            font-style: italic;
        }
        /* Responsive for mobile */
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Solana Wallet Toolkit</h1>
    <div class="container">
        <!-- Panel 1: Wallet and RPC -->
        <div class="panel">
            <h2>Wallet e RPC</h2>
            <select id="rpc-select">
                <option value="mainnet">Mainnet (api.mainnet-beta.solana.com)</option>
                <option value="publicnode">PublicNode (solana-rpc.publicnode.com)</option>
                <option value="devnet">Devnet (api.devnet.solana.com)</option>
                <option value="testnet">Testnet (api.testnet.solana.com)</option>
                <option value="helius">Helius</option>
                <option value="ankr">Ankr</option>
                <option value="custom">Custom RPC</option>
            </select>
            <input id="custom-rpc" class="hidden" placeholder="Enter custom RPC URL">
            <input id="helius-key" class="hidden" placeholder="Helius API Key" value="">
            <input id="ankr-key" class="hidden" placeholder="Ankr API Key" value="">
            <button id="connect-rpc">Conectar RPC</button>
            <p id="rpc-status">RPC Status: Desconectado</p>
            <button id="connect-wallet">Conectar Phantom</button>
            <button id="disconnect-wallet" class="hidden">Desconectar</button>
            <p id="wallet-address">Endereço: Não conectado <span class="loading hidden"> (Sincronizando...)</span></p>
            <p id="sol-balance">Saldo SOL: 0 (USD: 0)</p>
            <p id="sol-price">Preço SOL/USD: Carregando...</p>
            <button id="refresh-manual">Atualizar Manualmente</button>
        </div>

        <!-- Panel 2: Tokens and Transactions -->
        <div class="panel">
            <h2>Tokens SPL</h2>
            <ul id="tokens-list"></ul>
            <h2>Transações Recentes</h2>
            <ul id="txs-list"></ul>
        </div>

        <!-- Panel 3: Send SOL, Logs and Actions -->
        <div class="panel">
            <h2>Enviar SOL</h2>
            <input id="recipient" placeholder="Endereço do destinatário (base58)">
            <input id="amount" type="number" placeholder="Quantidade em SOL">
            <input id="memo" placeholder="Memo opcional">
            <button id="send-sol">Enviar SOL</button>
            <h2>Logs</h2>
            <div id="logs"></div>
            <button id="clear-logs">Limpar Logs</button>
            <button id="export-logs">Exportar Logs</button>
        </div>
    </div>

    <!-- Polyfill for Buffer (required for web3.js in browser) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/buffer/6.0.3/buffer.min.js"></script>

    <script type="module">
        import {
            Connection,
            Keypair,
            PublicKey,
            SystemProgram,
            Transaction,
            LAMPORTS_PER_SOL,
            getParsedTokenAccountsByOwner, // Incorrect, it's connection.getParsedTokenAccountsByOwner
            TOKEN_PROGRAM_ID,
            MemoProgram
        } from 'https://esm.sh/@solana/web3.js@1.95.3';

        // Make Buffer global for compatibility
        window.Buffer = buffer.Buffer;

        // Global variables
        let connection = null;
        let publicKey = null;
        let solPrice = 0;
        let logs = [];
        let autoUpdateInterval = null;
        const LOG_MAX = 150;
        const RPC_MAP = {
            mainnet: 'https://api.mainnet-beta.solana.com',
            publicnode: 'https://solana-rpc.publicnode.com',
            devnet: 'https://api.devnet.solana.com',
            testnet: 'https://api.testnet.solana.com',
            helius: '',
            ankr: '',
            custom: ''
        };
        const fallbackOrder = ['mainnet', 'publicnode', 'helius', 'ankr']; // Only mainnet fallbacks

        // Function to push logs (with level and message)
        function pushLog(level, msg) {
            const timestamp = new Date().toLocaleString('pt-BR');
            const logEntry = `[${timestamp}] [${level}] ${msg}`;
            logs.push(logEntry);
            if (logs.length > LOG_MAX) logs.shift();
            console.log(logEntry);
            document.getElementById('logs').innerText = logs.join('\n');
            document.getElementById('logs').scrollTop = document.getElementById('logs').scrollHeight;
        }

        // Fetch SOL price from CoinGecko
        async function fetchPrice() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
                const data = await response.json();
                solPrice = data.solana.usd;
                document.getElementById('sol-price').innerText = `Preço SOL/USD: $${solPrice.toFixed(2)}`;
                pushLog('PRICE', `SOL price updated to $${solPrice.toFixed(2)}`);
            } catch (error) {
                pushLog('ERROR', `Failed to fetch SOL price: ${error.message}`);
            }
        }

        // Try to connect to RPC with fallback
        async function tryConnectRpc(selected) {
            let rpcUrl = RPC_MAP[selected];
            if (selected === 'helius') {
                const key = localStorage.getItem('heliusKey') || '';
                if (!key) return pushLog('ERROR', 'Helius key not provided');
                rpcUrl = `https://mainnet.helius-rpc.com/?api-key=${key}`;
            } else if (selected === 'ankr') {
                const key = localStorage.getItem('ankrKey') || '';
                if (!key) return pushLog('ERROR', 'Ankr key not provided');
                rpcUrl = `https://rpc.ankr.com/solana/${key}`;
            } else if (selected === 'custom') {
                rpcUrl = document.getElementById('custom-rpc').value;
                if (!rpcUrl) return pushLog('ERROR', 'Custom RPC URL not provided');
            }

            pushLog('INIT', `Trying RPC: ${selected} (${rpcUrl})`);
            try {
                connection = new Connection(rpcUrl, 'confirmed');
                const version = await connection.getVersion();
                document.getElementById('rpc-status').innerText = `RPC Status: Conectado (${selected}) v${version['solana-core']}`;
                pushLog('INIT', `RPC connected: ${selected}`);
                return true;
            } catch (error) {
                pushLog('ERROR', `RPC ${selected} failed: ${error.message}`);
                return false;
            }
        }

        // Connect to selected RPC with fallback logic
        async function connectRpc() {
            const selected = document.getElementById('rpc-select').value;
            let success = await tryConnectRpc(selected);
            if (!success && fallbackOrder.includes(selected)) {
                for (let fallback of fallbackOrder) {
                    if (fallback !== selected) {
                        success = await tryConnectRpc(fallback);
                        if (success) {
                            document.getElementById('rpc-select').value = fallback;
                            break;
                        }
                    }
                }
            }
            if (!success) {
                document.getElementById('rpc-status').innerText = 'RPC Status: Falha ao conectar';
            }
        }

        // Update balance
        async function updateBalance() {
            if (!publicKey || !connection) return;
            showLoading(true);
            try {
                const balance = await connection.getBalance(publicKey);
                const sol = balance / LAMPORTS_PER_SOL;
                const usd = (sol * solPrice).toFixed(2);
                document.getElementById('sol-balance').innerText = `Saldo SOL: ${sol.toFixed(4)} (USD: $${usd})`;
                pushLog('BALANCE', `Balance updated: ${sol.toFixed(4)} SOL`);
            } catch (error) {
                pushLog('ERROR', `Failed to update balance: ${error.message}`);
            }
            showLoading(false);
        }

        // List SPL tokens
        async function listTokens() {
            if (!publicKey || !connection) return;
            const list = document.getElementById('tokens-list');
            list.innerHTML = '';
            try {
                const { value } = await connection.getParsedTokenAccountsByOwner(publicKey, { programId: TOKEN_PROGRAM_ID });
                value.forEach(({ account }) => {
                    const { data: { parsed: { info } } } = account;
                    if (info.tokenAmount.uiAmount > 0) {
                        const li = document.createElement('li');
                        li.innerText = `Mint: ${info.mint} | Amount: ${info.tokenAmount.uiAmount}`;
                        list.appendChild(li);
                    }
                });
                pushLog('WALLET', 'Tokens list updated');
            } catch (error) {
                pushLog('ERROR', `Failed to list tokens: ${error.message}`);
            }
        }

        // Load recent transactions
        async function loadTxs() {
            if (!publicKey || !connection) return;
            const list = document.getElementById('txs-list');
            list.innerHTML = '';
            try {
                const signatures = await connection.getSignaturesForAddress(publicKey, { limit: 20 });
                for (let sig of signatures) {
                    const tx = await connection.getParsedTransaction(sig.signature, { maxSupportedTransactionVersion: 0 });
                    if (tx) {
                        const li = document.createElement('li');
                        const time = new Date(tx.blockTime * 1000).toLocaleString('pt-BR');
                        li.innerText = `Sig: ${sig.signature.slice(0, 10)}... | Time: ${time} | Confirm: ${sig.confirmationStatus}`;
                        list.appendChild(li);
                    }
                }
                pushLog('TX', 'Transactions loaded');
            } catch (error) {
                pushLog('ERROR', `Failed to load txs: ${error.message}`);
            }
        }

        // Send SOL transaction
        async function sendSol() {
            if (!publicKey || !connection) return pushLog('ERROR', 'Wallet or RPC not connected');
            const recipient = document.getElementById('recipient').value;
            const amount = parseFloat(document.getElementById('amount').value);
            const memo = document.getElementById('memo').value;
            if (!recipient || isNaN(amount) || amount <= 0) return pushLog('ERROR', 'Invalid recipient or amount');

            try {
                const tx = new Transaction().add(
                    SystemProgram.transfer({
                        fromPubkey: publicKey,
                        toPubkey: new PublicKey(recipient),
                        lamports: amount * LAMPORTS_PER_SOL
                    })
                );
                if (memo) {
                    tx.add(MemoProgram.memo({ memo }));
                }
                const { signature } = await window.solana.signAndSendTransaction(tx);
                pushLog('TX', `SOL sent: Signature ${signature}`);
                await updateBalance();
                await loadTxs();
            } catch (error) {
                pushLog('ERROR', `Failed to send SOL: ${error.message}`);
            }
        }

        // Set connected UI
        function setConnectedUI(connected) {
            document.getElementById('connect-wallet').classList.toggle('hidden', connected);
            document.getElementById('disconnect-wallet').classList.toggle('hidden', !connected);
            document.getElementById('wallet-address').innerText = connected ? `Endereço: ${publicKey.toBase58()}` : 'Endereço: Não conectado';
            if (connected) {
                updateBalance();
                listTokens();
                loadTxs();
                if (autoUpdateInterval) clearInterval(autoUpdateInterval);
                autoUpdateInterval = setInterval(() => {
                    updateBalance();
                    listTokens();
                    loadTxs();
                }, 15000);
            } else {
                if (autoUpdateInterval) clearInterval(autoUpdateInterval);
                document.getElementById('sol-balance').innerText = 'Saldo SOL: 0 (USD: 0)';
                document.getElementById('tokens-list').innerHTML = '';
                document.getElementById('txs-list').innerHTML = '';
            }
        }

        // Connect wallet
        async function connectWallet() {
            if (!connection) return pushLog('ERROR', 'Connect RPC first');
            try {
                const { publicKey: pk } = await window.solana.connect({ onlyIfTrusted: false });
                publicKey = pk;
                setConnectedUI(true);
                pushLog('WALLET', `Wallet connected: ${publicKey.toBase58()}`);
            } catch (error) {
                pushLog('ERROR', `Failed to connect wallet: ${error.message}`);
            }
        }

        // Disconnect wallet
        async function disconnectWallet() {
            await window.solana.disconnect();
            publicKey = null;
            setConnectedUI(false);
            pushLog('WALLET', 'Wallet disconnected');
        }

        // Show loading indicator
        function showLoading(show) {
            document.querySelector('.loading').classList.toggle('hidden', !show);
        }

        // Event listeners
        document.getElementById('rpc-select').addEventListener('change', (e) => {
            const val = e.target.value;
            document.getElementById('custom-rpc').classList.toggle('hidden', val !== 'custom');
            document.getElementById('helius-key').classList.toggle('hidden', val !== 'helius');
            document.getElementById('ankr-key').classList.toggle('hidden', val !== 'ankr');
            if (val === 'helius') document.getElementById('helius-key').value = localStorage.getItem('heliusKey') || '';
            if (val === 'ankr') document.getElementById('ankr-key').value = localStorage.getItem('ankrKey') || '';
        });

        document.getElementById('helius-key').addEventListener('input', (e) => localStorage.setItem('heliusKey', e.target.value));
        document.getElementById('ankr-key').addEventListener('input', (e) => localStorage.setItem('ankrKey', e.target.value));

        document.getElementById('connect-rpc').addEventListener('click', connectRpc);
        document.getElementById('connect-wallet').addEventListener('click', connectWallet);
        document.getElementById('disconnect-wallet').addEventListener('click', disconnectWallet);
        document.getElementById('send-sol').addEventListener('click', sendSol);
        document.getElementById('refresh-manual').addEventListener('click', () => {
            updateBalance();
            listTokens();
            loadTxs();
            fetchPrice();
            pushLog('USER', 'Manual refresh triggered');
        });
        document.getElementById('clear-logs').addEventListener('click', () => {
            logs = [];
            document.getElementById('logs').innerText = '';
            pushLog('USER', 'Logs cleared');
        });
        document.getElementById('export-logs').addEventListener('click', () => {
            const blob = new Blob([logs.join('\n')], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'wallet_toolkit.log';
            a.click();
            URL.revokeObjectURL(url);
            pushLog('USER', 'Logs exported');
        });

        // Copy address on click
        document.getElementById('wallet-address').addEventListener('click', () => {
            if (publicKey) {
                navigator.clipboard.writeText(publicKey.toBase58());
                pushLog('USER', 'Address copied to clipboard');
            }
        });

        // Initial setup
        pushLog('INIT', 'App initialized');
        fetchPrice();
        setInterval(fetchPrice, 60000); // Update price every 60s
        document.getElementById('rpc-select').value = 'mainnet'; // Default
        connectRpc(); // Auto-connect default RPC
    </script>
</body>
</html>
