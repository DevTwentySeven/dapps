<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Solana Wallet Toolkit — v2</title>
<style>
  :root{--bg:#000;--panel:#071018;--muted:#9fb2d0;--accent:#00ff00;--accent-2:#00ff99;--danger:#ff6b6b}
  html,body{height:100%}
  body{font-family:Inter,Arial,Helvetica,sans-serif;margin:0;padding:0;background:var(--bg);color:#e6eef8;display:flex;flex-direction:column;min-height:100vh;}
  .app{max-width:1100px;margin:20px auto;padding:18px;box-sizing:border-box;width:95%}
  .top{display:flex;gap:12px;align-items:center;justify-content:space-between}
  .panel{background:rgba(0,0,0,0.55);border:1px solid rgba(0,255,0,0.12);padding:12px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,0.6)}
  .small{font-size:13px;color:var(--muted)}
  .muted{color:#91a7bf}
  .accent{color:var(--accent);font-weight:700}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  .col{flex:1 1 300px;min-width:260px}
  .button{background:transparent;border:1px solid var(--accent);color:var(--accent);padding:8px 12px;border-radius:8px;cursor:pointer}
  .button.primary{background:linear-gradient(90deg,rgba(0,255,153,0.08),rgba(0,255,153,0.03));border-color:var(--accent-2)}
  .button.danger{border-color:var(--danger);color:var(--danger)}
  #addrDisplay{cursor:pointer;color:var(--accent)}
  #qrcode{width:72px;height:72px;border-radius:8px;background:#081018;padding:6px}
  nav.tabs{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
  nav.tabs button{padding:8px 12px;border-radius:8px;border:1px solid rgba(0,255,0,0.08);background:transparent;color:var(--muted);cursor:pointer}
  nav.tabs button.active{background:linear-gradient(90deg,rgba(0,255,153,0.06),rgba(0,255,153,0.02));color:var(--accent);border-color:var(--accent-2)}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid rgba(0,255,0,0.03);text-align:left;font-size:14px}
  .token-icon{width:28px;height:28px;border-radius:6px;object-fit:cover;border:1px solid rgba(255,255,255,0.03)}
  .clickable{cursor:pointer}
  .toast{position:fixed;right:20px;bottom:20px;padding:12px 16px;border-radius:8px;background:#08121a;color:#cfeff1;box-shadow:0 8px 30px rgba(0,0,0,0.6);z-index:9999}
  .logs{height:160px;overflow:auto;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;font-size:13px}
  @media (max-width:800px){
    .top{flex-direction:column;align-items:stretch}
    nav.tabs{justify-content:space-around}
    #qrcode{width:56px;height:56px}
  }
  .neon { color:var(--accent); text-shadow:0 0 6px rgba(0,255,0,0.8); }
  .disabled { opacity: 0.5; pointer-events: none; }
  .spinner{display:inline-block;width:14px;height:14px;border:2px solid rgba(255,255,255,0.1);border-top:2px solid var(--accent);border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-left:8px}
  @keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}
</style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div style="flex:1">
        <div style="font-family:monospace;color:var(--accent);font-size:24px">Wallet Toolkit</div>
        <div class="small muted">Ferramenta para Phantom — abra em localhost ou GitHub Pages</div>
      </div>
      <div style="display:flex;gap:10px;align-items:center">
        <div style="text-align:right" class="panel">
          <div class="small">Status</div>
          <div id="connectStatus" class="neon">Desconectado</div>
          <div id="addrDisplay" class="small" title="Clique para copiar">--</div>
        </div>
        <div class="panel" style="text-align:right;min-width:160px">
          <div class="small">Saldo</div>
          <div id="solBalance" style="font-weight:700">-- SOL</div>
          <div id="usdBalance" class="small">-- USD (Fonte: CoinGecko)</div>
        </div>
        <div class="panel" style="text-align:center">
          <canvas id="qrcode"></canvas>
        </div>
      </div>
    </div>

    <nav class="tabs panel" id="tabs">
      <button data-tab="dashboard" class="active">Dashboard</button>
      <button data-tab="tokens">Tokens</button>
      <button data-tab="txs">Transações</button>
      <button data-tab="send">Enviar</button>
      <button data-tab="burn">Burn</button>
      <button data-tab="config">Config</button>
    </nav>

    <div id="content" style="margin-top:12px">
      <div id="tab-dashboard" class="panel tabpanel">
        <div class="row">
          <div class="col panel">
            <div class="small">Rede / RPC</div>
            <select id="rpcSelect" style="width:100%;margin-top:8px">
              <option value="https://api.devnet.solana.com">Devnet</option>
              <option value="https://api.testnet.solana.com">Testnet</option>
              <option value="https://api.mainnet-beta.solana.com">Mainnet</option>
              <option value="custom">Custom RPC</option>
            </select>
            <input id="customRpc" placeholder="https://..." style="margin-top:8px;display:none;width:100%"/>
            <div style="margin-top:12px">
              <button id="btnConnect" class="button primary">Conectar Phantom</button>
              <button id="btnDisconnect" class="button" style="margin-left:8px">Desconectar</button>
            </div>
          </div>

          <div class="col panel">
            <div class="small">Resumo</div>
            <div id="summary" style="margin-top:8px">
              <div class="small">Preço SOL (USD): <span id="solPrice">--</span></div>
              <div class="small">Tokens totais: <span id="totalTokens">--</span></div>
              <div class="small">Valor total (USD): <span id="portfolioUSD">--</span></div>
              <div class="small">Última atualização: <span id="lastUpdate">--</span></div>
            </div>
          </div>
        </div>
      </div>

      <div id="tab-tokens" class="panel tabpanel" style="display:none">
        <div class="small">Lista de tokens (auto-refresh a cada 2.7s)</div>
        <div style="overflow:auto;margin-top:10px">
          <table id="tokenTable">
            <thead><tr><th></th><th>Ticker</th><th>Nome</th><th>Quantidade</th><th>Valor (SOL)</th><th>Valor (USD)</th><th>Mint</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div id="tab-txs" class="panel tabpanel" style="display:none">
        <div class="small">Transações recentes</div>
        <div id="txList" style="margin-top:8px"></div>
      </div>

      <div id="tab-send" class="panel tabpanel" style="display:none">
        <div class="row">
          <div class="col">
            <div class="small">Tipo</div>
            <select id="sendType" style="width:100%;margin-top:6px"><option value="SOL">SOL</option><option value="TOKEN">Token SPL</option></select>
            <div class="small" style="margin-top:8px">Token (se aplicável)</div>
            <select id="tokenSelect" style="width:100%;margin-top:6px"><option value="">— selecione token —</option></select>
            <div style="margin-top:8px" class="small">Destinatários (uma linha = 1 destino). CSV: address,amount</div>
            <textarea id="targetAddrs" rows="6" style="width:100%;margin-top:6px" placeholder="Uma linha = um endereço (ou address,amount)"></textarea>
            <div style="margin-top:8px" class="small">Quantidade (mesma quantia)</div>
            <input id="amountInput" placeholder="ex: 0.5" style="width:100%;margin-top:6px"/>
            <div class="small" style="margin-top:8px">Memo (opcional)</div>
            <input id="memoInput" placeholder="observação" style="width:100%;margin-top:6px"/>
            <div style="margin-top:10px">
              <button id="btnSend" class="button primary">Enviar (mesma quantia)</button>
              <button id="btnAirdropCsv" class="button" style="margin-left:8px">Enviar CSV</button>
            </div>
            <div id="sendLog" class="small muted" style="margin-top:8px"></div>
          </div>

          <div class="col">
            <div class="small">Ações rápidas (devnet)</div>
            <button id="btnRequestAirdrop" class="button">Pedir Airdrop devnet (1 SOL)</button>
            <div style="margin-top:12px" class="small">Logs</div>
            <div class="logs" id="actionLogs"></div>
          </div>
        </div>
      </div>

      <div id="tab-burn" class="panel tabpanel" style="display:none">
        <div class="row">
          <div class="col">
            <div class="small">Escolha token para queimar (native burn)</div>
            <select id="burnTokenSelect" style="width:100%;margin-top:8px"><option value="">— selecione token —</option></select>
            <div style="margin-top:8px" class="small">Quantidade</div>
            <input id="burnAmount" placeholder="quantidade" style="width:100%;margin-top:6px"/>
            <div style="margin-top:10px">
              <button id="btnBurn" class="button danger">Burn nativo</button>
            </div>
            <div id="burnLog" class="small muted" style="margin-top:8px"></div>
          </div>

          <div class="col">
            <div class="small">Informações do mint</div>
            <div id="mintInfo" style="margin-top:8px" class="small-muted">Selecione um token</div>
          </div>
        </div>
      </div>

      <div id="tab-config" class="panel tabpanel" style="display:none">
        <div class="row">
          <div class="col">
            <div class="small">RPC atual</div>
            <div id="currentRpc" class="small-muted" style="margin-top:6px">--</div>
            <div style="margin-top:8px" class="small">Auto-refresh: 2.7s</div>
            <div style="margin-top:8px" class="small">Use RPCs dedicados para evitar rate limits</div>
          </div>
          <div class="col">
            <div class="small">Logs principais</div>
            <div class="logs" id="mainLogs"></div>
          </div>
        </div>
      </div>
    </div>

    <div style="height:24px"></div>
    <div class="small muted" style="text-align:center">Abra em <b>localhost</b> ou publique em <b>GitHub Pages</b>. Não rode em previews iframe.</div>
  </div>

  <div id="toastContainer"></div>

<script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>
<script src="https://unpkg.com/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrious/4.0.2/qrious.min.js"></script>

<script>
/* v2 improvements:
 - Robust Phantom detection with polling
 - Buttons disabled until Phantom ready
 - Explicit connect request on click (forces signature)
 - Fallback deep link hint if Phantom not available
 - Works on file://, localhost, 0.0.0.0 and GitHub Pages (best-effort)
*/
(async function(){
  const { Connection, PublicKey, Transaction, SystemProgram, LAMPORTS_PER_SOL, TransactionInstruction } = solanaWeb3;
  const spl = splToken;
  const TOKEN_PROGRAM_ID = spl.TOKEN_PROGRAM_ID;

  // UI refs
  const connectStatus = document.getElementById('connectStatus');
  const addrDisplay = document.getElementById('addrDisplay');
  const solBalanceEl = document.getElementById('solBalance');
  const usdBalanceEl = document.getElementById('usdBalance');
  const solPriceEl = document.getElementById('solPrice');
  const totalTokensEl = document.getElementById('totalTokens');
  const portfolioUSDEl = document.getElementById('portfolioUSD');
  const lastUpdateEl = document.getElementById('lastUpdate');
  const rpcSelect = document.getElementById('rpcSelect');
  const customRpc = document.getElementById('customRpc');
  const btnConnect = document.getElementById('btnConnect');
  const btnDisconnect = document.getElementById('btnDisconnect');
  const qrcodeCanvas = document.getElementById('qrcode');
  const qr = new QRious({element:qrcodeCanvas,size:120,value:''});

  const tokenTableBody = document.querySelector('#tokenTable tbody');
  const tokenSelect = document.getElementById('tokenSelect');
  const burnTokenSelect = document.getElementById('burnTokenSelect');
  const burnAmountInput = document.getElementById('burnAmount');
  const mintInfoDiv = document.getElementById('mintInfo');

  const txListDiv = document.getElementById('txList');

  const sendType = document.getElementById('sendType');
  const targetAddrs = document.getElementById('targetAddrs');
  const amountInput = document.getElementById('amountInput');
  const memoInput = document.getElementById('memoInput');
  const btnSend = document.getElementById('btnSend');
  const btnAirdropCsv = document.getElementById('btnAirdropCsv');
  const requestAirdropBtn = document.getElementById('btnRequestAirdrop');
  const sendLog = document.getElementById('sendLog');
  const actionLogs = document.getElementById('actionLogs');
  const burnLog = document.getElementById('burnLog');
  const mainLogs = document.getElementById('mainLogs');
  const refreshBalancesBtn = document.getElementById('refreshBalances');
  const currentRpc = document.getElementById('currentRpc');

  // state
  let connection = new Connection('https://api.devnet.solana.com','confirmed');
  let wallet = null;
  let pubkey = null;
  let solPriceUSD = null;
  let tokenListCache = null;
  let autoRefreshHandle = null;

  function logMain(...args){ const s = '['+new Date().toLocaleTimeString()+'] '+args.join(' ')+ '\n'; mainLogs.textContent = s + mainLogs.textContent; }
  function logAction(...args){ const s = '['+new Date().toLocaleTimeString()+'] '+args.join(' ')+ '\n'; actionLogs.textContent = s + actionLogs.textContent; }
  function toast(msg, t=2400){ const el = document.createElement('div'); el.className='toast'; el.textContent=msg; document.getElementById('toastContainer').appendChild(el); setTimeout(()=>el.remove(), t); }
  function setDisabled(state){
    [btnSend, btnAirdropCsv, requestAirdropBtn, btnBurn, document.getElementById('btnRequestAirdrop')].forEach(el=>{ if(!el) return; el.disabled=state; el.classList.toggle('disabled', state); });
  }

  // tabs
  document.querySelectorAll('nav.tabs button').forEach(b=>{
    b.addEventListener('click', ()=> {
      document.querySelectorAll('nav.tabs button').forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      document.querySelectorAll('.tabpanel').forEach(p=>p.style.display='none');
      document.getElementById('tab-'+b.dataset.tab).style.display='block';
    });
  });

  // phantom detection with polling
  async function detectPhantom(timeout=5000){
    const start = Date.now();
    while(Date.now()-start < timeout){
      if(window.solana && window.solana.isPhantom) return window.solana;
      if(window.phantom && window.phantom.solana) return window.phantom.solana;
      await new Promise(r=>setTimeout(r,200));
    }
    return null;
  }

  async function loadTokenList(){
    if(tokenListCache) return tokenListCache;
    try {
      const url = 'https://raw.githubusercontent.com/solana-labs/token-list/main/src/tokens/solana.tokenlist.json';
      const r = await fetch(url);
      const j = await r.json();
      tokenListCache = {};
      for(const t of j.tokens) tokenListCache[t.address] = t;
      logMain('Token list loaded: '+Object.keys(tokenListCache).length);
      return tokenListCache;
    } catch(e){ logMain('token-list load error', e.message); tokenListCache = {}; return tokenListCache; }
  }

  async function fetchSOLPrice(){
    try {
      const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd');
      const j = await r.json();
      solPriceUSD = j.solana.usd;
      solPriceEl.textContent = solPriceUSD ? solPriceUSD.toFixed(4) : '--';
      return solPriceUSD;
    } catch(e){ logMain('CoinGecko error', e.message); solPriceUSD = null; solPriceEl.textContent='--'; return null; }
  }

  // RPC change
  rpcSelect.addEventListener('change', ()=>{
    if(rpcSelect.value === 'custom'){ customRpc.style.display='block'; return; }
    customRpc.style.display='none';
    connection = new Connection(rpcSelect.value,'confirmed');
    currentRpc.textContent = rpcSelect.value;
    logMain('RPC switched to '+rpcSelect.value);
    if(pubkey) refreshAll();
  });
  customRpc.addEventListener('change', ()=>{ if(customRpc.value){ connection = new Connection(customRpc.value,'confirmed'); currentRpc.textContent = customRpc.value; if(pubkey) refreshAll(); } });

  // copy helper
  async function copy(text, label='copiado'){ try{ await navigator.clipboard.writeText(text); toast(label); }catch(e){ toast('falha copiar'); } }

  // connect logic
  btnConnect.addEventListener('click', async ()=>{
    try {
      btnConnect.disabled = true;
      btnConnect.innerHTML = 'Conectando <span class="spinner"></span>';
      const ph = await detectPhantom(4000);
      if(!ph){
        btnConnect.innerHTML = 'Conectar Phantom';
        btnConnect.disabled = false;
        toast('Phantom não detectado. Abra o navegador com a extensão Phantom instalada.');
        logMain('Phantom not found');
        return;
      }
      wallet = ph;
      // Force the wallet to ask for signature every time by calling connect with onlyIfTrusted:false
      const resp = await wallet.connect({ onlyIfTrusted:false });
      pubkey = resp.publicKey;
      connectStatus.textContent = 'Conectado';
      addrDisplay.textContent = pubkey.toString();
      addrDisplay.onclick = ()=>copy(pubkey.toString(),'Endereço copiado');
      qr.value = pubkey.toString();
      toast('Carteira conectada');
      logMain('Connected ' + pubkey.toString());
      await loadTokenList();
      await fetchSOLPrice();
      await refreshAll();
      startAutoRefresh();
      wallet.on('accountChanged', async (pk)=>{ if(pk){ pubkey = pk; addrDisplay.textContent = pubkey.toString(); qr.value = pubkey.toString(); await refreshAll(); } else { pubkey = null; connectStatus.textContent='Desconectado'; addrDisplay.textContent='--'; stopAutoRefresh(); } });
    } catch(e){
      logMain('connect error '+(e.message||e));
      toast('Erro conectar: '+(e.message||e));
    } finally {
      btnConnect.disabled = false;
      btnConnect.innerHTML = 'Conectar Phantom';
    }
  });

  btnDisconnect.addEventListener('click', async ()=>{
    try{
      if(wallet && wallet.disconnect) await wallet.disconnect();
      pubkey = null;
      connectStatus.textContent='Desconectado';
      addrDisplay.textContent='--';
      qr.value = '';
      stopAutoRefresh();
      toast('Desconectado');
    }catch(e){ logMain('disconnect error '+(e.message||e)); toast('Erro desconectar'); }
  });

  // tokens
  async function listTokens(){
    tokenTableBody.innerHTML = '<tr><td colspan="7" class="small muted">Carregando...</td></tr>';
    tokenSelect.innerHTML = '<option value="">— selecione token —</option>';
    burnTokenSelect.innerHTML = '<option value="">— selecione token —</option>';
    if(!pubkey) { tokenTableBody.innerHTML='<tr><td colspan="7">Conecte a wallet</td></tr>'; return; }
    try {
      const res = await connection.getParsedTokenAccountsByOwner(pubkey, { programId: TOKEN_PROGRAM_ID });
      const tokens = [];
      for(const v of res.value){
        const info = v.account.data.parsed.info;
        const mint = info.mint;
        const amount = info.tokenAmount.uiAmount || 0;
        const decimals = info.tokenAmount.decimals || 0;
        tokens.push({mint,amount,decimals,account:v.pubkey.toString()});
      }
      const cc = tokenListCache || await loadTokenList();
      const coingeckoIds = [];
      for(const t of tokens){
        const meta = cc[t.mint];
        if(meta && meta.extensions && meta.extensions.coingeckoId) coingeckoIds.push(meta.extensions.coingeckoId);
      }
      let tokenPrices = {};
      if(coingeckoIds.length){
        const ids = Array.from(new Set(coingeckoIds)).join(',');
        try {
          const r = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${encodeURIComponent(ids)}&vs_currencies=usd`);
          tokenPrices = await r.json();
        } catch(e){ logMain('token price fetch error '+(e.message||e)); tokenPrices = {}; }
      }
      // render
      tokenTableBody.innerHTML = '';
      let portfolioUSD = 0;
      let countTokens = 0;
      for(const t of tokens){
        const meta = cc[t.mint];
        const symbol = meta ? meta.symbol : (t.mint.slice(0,6)+'...');
        const name = meta ? meta.name : '';
        const icon = meta && meta.logoURI ? meta.logoURI : '';
        let usdPrice = null;
        if(meta && meta.extensions && meta.extensions.coingeckoId && tokenPrices[meta.extensions.coingeckoId]) usdPrice = tokenPrices[meta.extensions.coingeckoId].usd;
        const valueUSD = (usdPrice ? usdPrice * t.amount : null);
        const valueSOL = (valueUSD && solPriceUSD) ? (valueUSD / solPriceUSD) : null;
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${icon?'<img src="'+icon+'" class="token-icon" onerror="this.style.display=\\'none\\'"/>':''}</td>
          <td class="clickable">${symbol}</td>
          <td>${name||'—'}</td>
          <td>${t.amount.toLocaleString()}</td>
          <td>${valueSOL!==null?valueSOL.toFixed(6):'—'}</td>
          <td>${valueUSD!==null?('$'+valueUSD.toFixed(4)):'—'}</td>
          <td style="font-size:12px;color:var(--muted)">${t.mint}</td>
        `;
        tr.querySelector('.clickable').addEventListener('click', ()=>{ copy(t.mint,'Mint copiado'); });
        tokenTableBody.appendChild(tr);
        if(t.amount>0){
          const opt = document.createElement('option'); opt.value=JSON.stringify({mint:t.mint,account:t.account,decimals:t.decimals}); opt.textContent = `${symbol} — ${t.amount}`;
          tokenSelect.appendChild(opt);
          burnTokenSelect.appendChild(opt.cloneNode(true));
        }
        if(valueUSD) portfolioUSD += valueUSD;
        countTokens += 1;
      }
      totalTokensEl.textContent = countTokens;
      portfolioUSDEl.textContent = portfolioUSD ? ('$'+portfolioUSD.toFixed(2)) : '--';
    } catch(e){
      tokenTableBody.innerHTML = '<tr><td colspan="7">Erro carregando tokens</td></tr>';
      logMain('listTokens error '+(e.message||e));
    }
  }

  async function listTxs(){
    txListDiv.innerHTML = 'Carregando...';
    if(!pubkey) { txListDiv.innerHTML = 'Conecte a wallet'; return; }
    try {
      const sigs = await connection.getSignaturesForAddress(pubkey,{limit:15});
      if(!sigs||!sigs.length){ txListDiv.innerHTML='Sem transações recentes'; return; }
      txListDiv.innerHTML = sigs.map(s=> {
        const status = s.err ? '❌' : '✅';
        const time = s.blockTime ? new Date(s.blockTime*1000).toLocaleString() : '-';
        const short = s.signature.slice(0,12)+'...';
        const cluster = rpcSelect.value.includes('devnet') ? 'devnet' : (rpcSelect.value.includes('testnet')?'testnet':'mainnet');
        const link = `https://explorer.solana.com/tx/${s.signature}?cluster=${cluster}`;
        return `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.02)"><a href="${link}" target="_blank" style="color:var(--accent)">${short}</a> — ${status} <div class="small muted">${time}</div></div>`;
      }).join('');
    } catch(e){ txListDiv.innerHTML = 'Erro carregando txs'; logMain('listTxs err '+(e.message||e)); }
  }

  async function refreshAll(){
    if(!pubkey) return;
    try {
      await fetchSOLPrice();
      const lam = await connection.getBalance(pubkey);
      const sol = lam / LAMPORTS_PER_SOL;
      solBalanceEl.textContent = sol.toFixed(6) + ' SOL';
      usdBalanceEl.textContent = solPriceUSD ? ('$'+(sol*solPriceUSD).toFixed(2)) : '--';
      lastUpdateEl.textContent = new Date().toLocaleTimeString();
      await listTokens();
      await listTxs();
    } catch(e){ logMain('refreshAll err '+(e.message||e)); }
  }

  function startAutoRefresh(){ stopAutoRefresh(); autoRefreshHandle = setInterval(()=>{ if(pubkey) refreshAll().catch(e=>logMain('auto refresh '+(e.message||e))); }, 2700); }
  function stopAutoRefresh(){ if(autoRefreshHandle) clearInterval(autoRefreshHandle); autoRefreshHandle = null; }

  // send functions
  async function sendSOL(toPub, amountSol, memo){
    const tx = new Transaction().add(SystemProgram.transfer({
      fromPubkey: pubkey,
      toPubkey: toPub,
      lamports: Math.round(amountSol * LAMPORTS_PER_SOL)
    }));
    if(memo) tx.add(new TransactionInstruction({keys:[],programId:new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),data:Buffer.from(memo)}));
    const signed = await wallet.signAndSendTransaction(tx);
    return signed.signature;
  }

  async function sendToken(info, toAddr, amount, memo){
    const mint = new PublicKey(info.mint);
    const fromAcc = new PublicKey(info.account);
    const decimals = parseInt(info.decimals || 0);
    const toPub = new PublicKey(toAddr);
    const toATA = await spl.getAssociatedTokenAddress(mint, toPub);
    const ataInfo = await connection.getAccountInfo(toATA);
    const tx = new Transaction();
    if(!ataInfo) tx.add(spl.createAssociatedTokenAccountInstruction(pubkey, toATA, toPub, mint));
    const rawAmount = Math.round(amount * (10 ** decimals));
    tx.add(spl.createTransferInstruction(fromAcc, toATA, pubkey, rawAmount, [], TOKEN_PROGRAM_ID));
    if(memo) tx.add(new TransactionInstruction({keys:[],programId:new PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),data:Buffer.from(memo)}));
    const signed = await wallet.signAndSendTransaction(tx);
    return signed.signature;
  }

  btnSend.addEventListener('click', async ()=>{
    if(!pubkey) return alert('Conecte Phantom');
    const lines = targetAddrs.value.split('\n').map(l=>l.trim()).filter(Boolean);
    if(!lines.length) return alert('Inclua destinatários');
    const amt = parseFloat(amountInput.value);
    const memo = memoInput.value || null;
    try {
      if(sendType.value === 'SOL'){
        if(isNaN(amt) || amt <= 0) return alert('Quantidade inválida');
        for(const l of lines){
          const toStr = l.split(',')[0].trim();
          const to = new PublicKey(toStr);
          const sig = await sendSOL(to, amt, memo);
          sendLog.textContent += `SOL -> ${to.toString()} tx:${sig}\n`;
          logAction('SOL sent '+sig);
        }
      } else {
        const sel = tokenSelect.value;
        if(!sel) return alert('Selecione token');
        const info = JSON.parse(sel);
        if(isNaN(amt) || amt <= 0) return alert('Quantidade inválida');
        for(const l of lines){
          const toStr = l.split(',')[0].trim();
          const sig = await sendToken(info, toStr, amt, memo);
          sendLog.textContent += `Token -> ${toStr} tx:${sig}\n`;
          logAction('Token sent '+sig);
        }
      }
      await refreshAll();
    } catch(e){ sendLog.textContent += 'Erro: '+(e.message||e)+'\n'; logMain('send err '+(e.message||e)); }
  });

  btnAirdropCsv.addEventListener('click', async ()=>{
    if(!pubkey) return alert('Conecte Phantom');
    const lines = targetAddrs.value.split('\n').map(l=>l.trim()).filter(Boolean);
    if(!lines.length) return alert('Nada para enviar');
    try {
      for(const l of lines){
        const parts = l.split(',').map(p=>p.trim());
        if(parts.length<2) continue;
        const to = parts[0];
        const amt = parseFloat(parts[1]);
        if(sendType.value === 'SOL'){
          const sig = await sendSOL(new PublicKey(to), amt, memoInput.value||null);
          sendLog.textContent += `SOL -> ${to} tx:${sig}\n`;
        } else {
          const info = JSON.parse(tokenSelect.value);
          const sig = await sendToken(info, to, amt, memoInput.value||null);
          sendLog.textContent += `Token -> ${to} tx:${sig}\n`;
        }
      }
      await refreshAll();
    } catch(e){ sendLog.textContent += 'Erro CSV: '+(e.message||e)+'\n'; logMain('airdrop csv err '+(e.message||e)); }
  });

  requestAirdropBtn.addEventListener('click', async ()=>{
    if(!pubkey) return alert('Conecte Phantom');
    if(!rpcSelect.value.includes('devnet')) return alert('Airdrop somente em devnet');
    try {
      const sig = await connection.requestAirdrop(pubkey, LAMPORTS_PER_SOL);
      actionLogs.textContent = '['+new Date().toLocaleTimeString()+'] Airdrop solicitado: '+sig+'\n' + actionLogs.textContent;
      await connection.confirmTransaction(sig);
      await refreshAll();
    } catch(e){ actionLogs.textContent = '['+new Date().toLocaleTimeString()+'] Erro airdrop: '+(e.message||e)+'\n' + actionLogs.textContent; }
  });

  document.getElementById('btnBurn').addEventListener('click', async ()=>{
    if(!pubkey) return alert('Conecte Phantom');
    if(!burnTokenSelect.value) return alert('Selecione token');
    const info = JSON.parse(burnTokenSelect.value);
    const amt = parseFloat(burnAmountInput.value);
    if(isNaN(amt) || amt <=0) return alert('quantia inválida');
    const decimals = parseInt(info.decimals||0);
    const raw = Math.round(amt * (10 ** decimals));
    try {
      const ix = spl.createBurnInstruction(new PublicKey(info.account), new PublicKey(info.mint), pubkey, raw, [], TOKEN_PROGRAM_ID);
      const tx = new Transaction().add(ix);
      const sig = await wallet.signAndSendTransaction(tx);
      burnLog.textContent = `Burn tx: ${sig.signature}`;
      logAction('Burn '+sig.signature);
      await new Promise(r=>setTimeout(r,2500));
      await refreshAll();
    } catch(e){ burnLog.textContent = 'Erro burn: '+(e.message||e); logMain('burn err '+(e.message||e)); }
  });

  burnTokenSelect.addEventListener('change', async ()=>{
    const v = burnTokenSelect.value;
    if(!v){ mintInfoDiv.textContent='Selecione um token'; return; }
    const info = JSON.parse(v);
    try {
      const mintAcc = await connection.getParsedAccountInfo(new PublicKey(info.mint));
      if(mintAcc && mintAcc.value && mintAcc.value.data && mintAcc.value.data.parsed){
        const p = mintAcc.value.data.parsed.info;
        mintInfoDiv.innerHTML = `<div class="small">Decimals: ${p.decimals} • Supply: ${p.supply}</div>`;
      } else mintInfoDiv.textContent = 'Não foi possível ler o mint';
    } catch(e){ mintInfoDiv.textContent = 'Erro lendo mint'; }
  });

  // initial phantom detection
  const ph = await detectPhantom(2000);
  if(ph){
    connectStatus.textContent = 'Disponível (clique Conectar)';
    toast('Phantom disponível — clique Conectar para pedir assinatura');
  } else {
    connectStatus.textContent = 'Phantom não detectado';
    toast('Phantom não detectada. Instale a extensão: https://phantom.app');
  }

  // initial load resources
  await loadTokenList();
  await fetchSOLPrice();
  currentRpc.textContent = rpcSelect.value;

  // expose for debugging
  window.walletToolkit = { refreshAll, connection };

})();
</script>
</body>
</html>
