<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' 'unsafe-eval' data:;">
<title>Airdrop 27 coin — Devnet Dashboard</title>
<style>
  :root{
    --gap:12px;--muted:#666;--bg:#f7f8fa;--card:#fff;--accent:#0b74ff;
    --danger:#d9534f;--success:#28a745;--info:#007bff;
    --shadow:0 6px 18px rgba(20,20,30,0.06);
  }
  *{box-sizing:border-box}body{font-family:Inter,system-ui;
  margin:0;padding:18px;background:var(--bg);color:#111;}
  .container{max-width:1100px;margin:0 auto;display:grid;gap:var(--gap);}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between}
  header h1{font-size:18px;margin:0}header p{margin:0;color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns:1fr;gap:var(--gap);}
  .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:var(--shadow);}
  .balance{display:flex;flex-direction:column;gap:8px;}
  .balance .amount{font-size:22px;font-weight:600}.small{font-size:13px;color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button{border:0;padding:10px 12px;border-radius:8px;background:var(--accent);
  color:white;font-weight:600;cursor:pointer;}
  button.secondary{background:#555}button.ghost{background:transparent;color:var(--accent);border:1px solid #e6e9ef}
  button:disabled{opacity:.5;cursor:not-allowed}
  .logs{max-height:220px;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:6px;
  font-family:monospace;font-size:13px}
  .log-item{padding:8px;border-radius:6px;background:#fbfcff;border:1px solid #eef2ff}
  .log-item.error{border-color:rgba(217,83,79,0.15);color:var(--danger)}
  .log-item.success{border-color:rgba(40,167,69,0.12);color:var(--success)}
  .log-item.info{border-color:rgba(0,123,255,0.08);color:var(--info)}
  table{width:100%;border-collapse:collapse;font-size:13px}
  th,td{padding:8px;text-align:left;border-bottom:1px solid #eef2ff}
  th{background:#fbfcff;font-weight:700}
  .tx-highlight{background:linear-gradient(90deg,rgba(11,116,255,0.06),transparent)}
  .tx-ok{color:var(--success);font-weight:700}
  .tx-bad{color:var(--danger);font-weight:700}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .muted{color:var(--muted);font-size:13px}.note{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="container">
  <header>
    <div>
      <h1>Airdrop 27 coin — Devnet</h1>
      <p>Painel de envio, status e histórico (mobile + desktop)</p>
    </div>
    <div class="controls">
      <button id="connectBtn">Conectar Phantom</button>
      <button id="disconnectBtn" class="secondary" style="display:none">Desconectar</button>
      <button id="sendBtn" style="display:none">Enviar Airdrop (0.00527 SOL)</button>
      <button id="refreshTxBtn" class="ghost">Atualizar TX</button>
    </div>
  </header>

  <div class="grid">
    <!-- 1️⃣ Dados principais -->
    <div class="card balance">
      <div><div class="small">Carteira</div><div id="walletAddr" class="muted">—</div></div>
      <div><div class="small">Saldo (SOL)</div><div id="balance" class="amount">—</div>
        <div class="note">Atualiza automaticamente após transações</div></div>
      <div><div class="small">Memo (fixo)</div><div id="memoText" class="muted">Inscrito Airdrop 27 coin</div></div>
    </div>

    <!-- 2️⃣ Logs -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Status / Logs</strong></div><div class="muted">últimos 100</div>
      </div>
      <div id="logs" class="logs" aria-live="polite"></div>
      <div style="margin-top:8px;display:flex;gap:8px">
        <button id="clearLogs" class="ghost">Limpar logs</button>
      </div>
    </div>

    <!-- 3️⃣ Transações -->
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Últimas transações (20)</strong></div><div class="muted">Busca por transações recentes</div>
      </div>
      <div style="margin-top:8px;overflow:auto">
        <table id="txTable" role="table" aria-live="polite">
          <thead><tr><th>Sig</th><th>Slot</th><th>Direção</th><th>Valor</th><th>Status</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="note">Transações para o endereço do airdrop são destacadas com <strong>"Airdrop 27 coin confirmado!"</strong></div>
    </div>
  </div>
</div>

<script src="./web3.iife.min.js"></script>
<script>
(function(){

  // ---------- CONFIG ----------
  const RPC_ENDPOINT='https://api.devnet.solana.com';
  const DESTINATION_ADDRESS='2ZjGzzYYiPwHXchTcVMzikH8v9kY6y5tFnmcNJauK1XD';
  const AIRDROP_AMOUNT=0.00527;
  const MEMO_TEXT='Inscrito Airdrop 27 coin';
  const TX_HISTORY_LIMIT=20;
  const LOG_LIMIT=100;
  const RETRY_SEND_ATTEMPTS=2;

  // When fetching all signatures we cap to avoid infinite loops / huge RPC load:
  const FULL_SIG_BATCH = 1000;       // batch size per page
  const FULL_SIG_MAX = 5000;        // maximum signatures to fetch in full scan (adjust if needed)

  // ---------- STATE & UI ----------
  const connection=new solanaWeb3.Connection(RPC_ENDPOINT,'confirmed');
  let wallet=null, publicKey=null, isProcessing=false, logs=[];
  const connectBtn=document.getElementById('connectBtn');
  const disconnectBtn=document.getElementById('disconnectBtn');
  const sendBtn=document.getElementById('sendBtn');
  const refreshTxBtn=document.getElementById('refreshTxBtn');
  const clearLogsBtn=document.getElementById('clearLogs');
  const logsDiv=document.getElementById('logs');
  const balanceEl=document.getElementById('balance');
  const walletAddrEl=document.getElementById('walletAddr');
  const txTableBody=document.querySelector('#txTable tbody');

  // ---------- HELPERS ----------
  function ts(){return new Date().toISOString().replace('T',' ').slice(0,19);}
  function short(sig){return sig?sig.slice(0,8)+'...':'—';}
  function sol(lamports){return (lamports/solanaWeb3.LAMPORTS_PER_SOL).toFixed(6);}
  function pushLog(msg,lvl='info'){
    const e={t:Date.now(),ts:ts(),msg,lvl};
    logs.unshift(e);
    if(logs.length>LOG_LIMIT) logs=logs.slice(0,LOG_LIMIT);
    renderLogs();
    // console trace
    if(lvl==='error') console.error(`[${e.ts}]`,msg); else console.log(`[${e.ts}]`,msg);
  }
  function renderLogs(){
    logsDiv.innerHTML='';
    for(const e of logs){
      const d=document.createElement('div');
      d.className='log-item '+(e.lvl==='error'?'error':e.lvl==='success'?'success':'info');
      d.textContent=`[${e.ts}] ${e.msg}`;
      logsDiv.appendChild(d);
    }
  }
  function setBalance(t){balanceEl.textContent=t;}
  function setWalletAddr(t){walletAddrEl.textContent=t;}

  // ---------- WALLET ----------
  async function connectWallet(){
    try{
      if(!window.solana||!window.solana.isPhantom) return pushLog('Phantom Wallet não detectada.','error');
      wallet=window.solana; pushLog('Tentando conectar...','info');
      const r=await wallet.connect(); publicKey=r.publicKey; setWalletAddr(publicKey.toBase58());
      pushLog('Conectado: '+publicKey.toBase58(),'success');
      connectBtn.style.display='none'; disconnectBtn.style.display='inline-block'; sendBtn.style.display='inline-block';
      await refreshBalance(); await refreshTxHistory();
    }catch(err){ pushLog('Erro ao conectar: '+(err.message||err),'error'); }
  }

  function disconnectWallet(){
    try{ wallet && wallet.disconnect && wallet.disconnect(); }catch{}
    wallet=null; publicKey=null; setWalletAddr('—'); setBalance('—');
    connectBtn.style.display='inline-block'; disconnectBtn.style.display='none'; sendBtn.style.display='none';
    txTableBody.innerHTML=''; pushLog('Desconectado.','info');
  }

  // ---------- BALANCE ----------
  async function refreshBalance(){
    if(!publicKey) return;
    try{
      const lam=await connection.getBalance(publicKey);
      setBalance(sol(lam)+' SOL'); pushLog('Saldo atualizado: '+sol(lam)+' SOL','info');
    }catch(e){ pushLog('Erro ao buscar saldo: '+(e.message||e),'error'); }
  }

  // ---------- BUILD TX ----------
  function buildTransferTx({fromPubkey,toPubkey,lamports,blockhash}){
    const tx=new solanaWeb3.Transaction({recentBlockhash:blockhash,feePayer:fromPubkey});
    tx.add(solanaWeb3.SystemProgram.transfer({fromPubkey,toPubkey,lamports}));
    const memoProg=new solanaWeb3.PublicKey('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr');
    tx.add(new solanaWeb3.TransactionInstruction({keys:[],programId:memoProg,data:new TextEncoder().encode(MEMO_TEXT)}));
    return tx;
  }

  // ---------- SEND FLOW (com retry blockhash e confirm async) ----------
  async function sendAirdrop(){
    if(!wallet||!publicKey) return pushLog('Conecte a Phantom antes.','error');
    if(isProcessing) return pushLog('Aguarde outra operação.','info');
    isProcessing=true; sendBtn.disabled=true; pushLog('Iniciando envio...','info');
    let attempt=0,lastErr=null;
    while(attempt<RETRY_SEND_ATTEMPTS){
      attempt++;
      try{
        const latest = await connection.getLatestBlockhash('finalized');
        const tx = buildTransferTx({
          fromPubkey: publicKey,
          toPubkey: new solanaWeb3.PublicKey(DESTINATION_ADDRESS),
          lamports: Math.round(AIRDROP_AMOUNT*solanaWeb3.LAMPORTS_PER_SOL),
          blockhash: latest.blockhash
        });
        const signed = await wallet.signTransaction(tx);
        const raw = signed.serialize();
        const sig = await connection.sendRawTransaction(raw,{skipPreflight:false});
        pushLog('Assinatura enviada: '+sig,'info');
        // confirm asynchronously
        confirmTxAsync(sig, latest);
        pushLog('✅ Airdrop enviado! aguardando confirmação...','success');
        await refreshBalance(); await refreshTxHistory();
        isProcessing=false; sendBtn.disabled=false; return sig;
      }catch(err){
        lastErr=err;
        const emsg = err && err.message ? err.message : String(err);
        if(emsg.includes('Blockhash not found') || emsg.includes('blockhash')){
          pushLog('Blockhash expirado, tentando nova tentativa.','info');
          continue;
        }
        if(emsg.includes('User rejected')){ pushLog('Envio cancelado pelo usuário.','error'); break; }
        pushLog('Erro ao enviar: '+emsg,'error');
      }
    }
    isProcessing=false; sendBtn.disabled=false;
    pushLog('Falha após '+RETRY_SEND_ATTEMPTS+' tentativas.','error');
  }

  async function confirmTxAsync(sig, latest){
    try{
      const res = await connection.confirmTransaction({signature:sig, blockhash: latest.blockhash, lastValidBlockHeight: latest.lastValidBlockHeight}, 'confirmed');
      if(res && res.value && res.value.err === null){
        pushLog('✅ Confirmação completa: '+sig,'success');
        await refreshTxHistory();
      } else {
        pushLog('⚠️ Confirmação pendente ou com erro: '+sig,'info');
      }
    }catch(e){
      pushLog('Aviso na confirmação: '+(e.message||e),'info');
    }
  }

  // ---------- FETCH ALL SIGNATURES (paginated) ----------
  async function fetchAllSignaturesPubkey(pubkey){
    const all = [];
    let before = undefined;
    try{
      while(true){
        const opts = { limit: FULL_SIG_BATCH };
        if(before) opts.before = before;
        const batch = await connection.getSignaturesForAddress(pubkey, opts);
        if(!batch || batch.length===0) break;
        all.push(...batch);
        if(batch.length < FULL_SIG_BATCH) break;
        if(all.length >= FULL_SIG_MAX) { pushLog('Limite de leitura completo ('+FULL_SIG_MAX+').', 'info'); break; }
        before = batch[batch.length-1].signature;
        // pequena pausa para reduzir risco de rate-limit
        await new Promise(r => setTimeout(r, 250));
      }
    }catch(e){
      pushLog('Erro ao coletar assinaturas completas: '+(e.message||e),'error');
    }
    return all;
  }

  // ---------- DETECT REGISTRATION (scan parsed transactions) ----------
  async function detectRegistrationInAll(){
    if(!publicKey) return false;
    pushLog('Escaneando histórico completo (pode levar alguns segundos)...','info');
    const allInfos = await fetchAllSignaturesPubkey(publicKey);
    if(!allInfos || allInfos.length===0){
      pushLog('Nenhuma assinatura encontrada no histórico completo.','info');
      return false;
    }
    // memo program id string
    const memoProgId = 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr';
    for(const info of allInfos){
      try{
        // If the signature info already contains memo (fast path), use it as hint
        if(info.memo && info.memo === MEMO_TEXT){
          // confirm transfer destination by fetching parsed tx
          const parsed = await connection.getParsedTransaction(info.signature, 'confirmed');
          if(parsed && parsed.transaction && parsed.transaction.message){
            const instructions = parsed.transaction.message.instructions || [];
            // find any system transfer to DESTINATION_ADDRESS
            let hasTransferToDest = false;
            for(const ix of instructions){
              try{
                if(ix.program === 'system' && ix.parsed && ix.parsed.type === 'transfer'){
                  const dest = ix.parsed.info && ix.parsed.info.destination;
                  if(dest === DESTINATION_ADDRESS){ hasTransferToDest = true; break; }
                }
              }catch(e){}
            }
            if(hasTransferToDest){
              pushLog('Registro encontrado (via info.memo): '+info.signature,'success');
              return true;
            }
          }
        } else {
          // fallback: parse the transaction and search for memo+transfer
          const parsed = await connection.getParsedTransaction(info.signature, 'confirmed');
          if(!parsed || !parsed.transaction || !parsed.transaction.message) continue;
          const instructions = parsed.transaction.message.instructions || [];
          // flags
          let memoMatch = false;
          let transferToDest = false;
          // check each instruction
          for(const ix of instructions){
            try{
              // memo check (parsed)
              if(ix.program === 'spl-memo' || (ix.programId && ix.programId.toBase58 && ix.programId.toBase58() === memoProgId)){
                // parsed memo could be in ix.parsed (string) or ix.parsed.memo
                if(typeof ix.parsed === 'string' && ix.parsed === MEMO_TEXT) memoMatch = true;
                else if(ix.parsed && (ix.parsed.memo === MEMO_TEXT || ix.parsed === MEMO_TEXT)) memoMatch = true;
                else if(ix.data){
                  // attempt base64 decode (most parsed txs expose data base64)
                  try{
                    const dec = atob(ix.data);
                    if(dec === MEMO_TEXT) memoMatch = true;
                  }catch(_){}
                }
              }
              // transfer detection (parsed system)
              if(ix.program === 'system' && ix.parsed && ix.parsed.type === 'transfer'){
                const dest = ix.parsed.info && ix.parsed.info.destination;
                if(dest === DESTINATION_ADDRESS) transferToDest = true;
              }
            }catch(e){}
          }
          if(memoMatch && transferToDest){
            pushLog('Registro encontrado: '+info.signature,'success');
            return true;
          }
        }
      }catch(e){
        // ignore single tx errors but log debug
        // pushLog('Aviso ao checar tx '+info.signature+': '+(e.message||e),'info');
      }
    }
    // none found
    return false;
  }

  // ---------- REFRESH TX HISTORY (shows last 20 but uses detectRegistrationInAll for blocking) ----------
  async function refreshTxHistory(){
    if(!publicKey) return;
    pushLog('Buscando últimas transações...','info');
    try{
      // Get latest signature infos (20) for table
      const sigInfos = await connection.getSignaturesForAddress(publicKey, { limit: TX_HISTORY_LIMIT });
      const rows = [];
      for(const info of sigInfos){
        let dir='—', val='—', to=null;
        try{
          // Use parsed transaction to reliably get direction/value
          const parsed = await connection.getParsedTransaction(info.signature, {commitment:'confirmed'});
          if(parsed && parsed.meta && parsed.meta.preBalances && parsed.meta.postBalances && parsed.transaction && parsed.transaction.message){
            const pre = parsed.meta.preBalances, post = parsed.meta.postBalances, msg = parsed.transaction.message;
            const idx = msg.accountKeys.findIndex(k => k.toBase58() === publicKey.toBase58());
            if(idx >= 0){
              const delta = post[idx] - pre[idx];
              val = (Math.abs(delta) / solanaWeb3.LAMPORTS_PER_SOL).toFixed(6) + ' SOL';
              dir = delta < 0 ? 'out' : 'in';
            }
            // check if dest present
            const accs = msg.accountKeys.map(k => k.toBase58());
            if(accs.includes(DESTINATION_ADDRESS)) to = DESTINATION_ADDRESS;
          }
        }catch(e){
          // ignore single tx parse errors
        }
        rows.push({ signature: info.signature, slot: info.slot, direction: dir, value: val, status: info.err ? 'failed' : 'confirmed', toAddr: to });
      }
      renderTxTable(rows);

      // Now run the full-scan to detect prior registration (this can take time)
      const already = await detectRegistrationInAll();
      if(already){
        sendBtn.disabled = true;
        sendBtn.textContent = 'Você já se inscreveu para o airdrop';
        pushLog('Airdrop anterior detectado — envio bloqueado.','success');
      } else {
        sendBtn.disabled = false;
        sendBtn.textContent = 'Enviar Airdrop (0.00527 SOL)';
        pushLog('Nenhum airdrop anterior detectado.','info');
      }

    }catch(e){
      pushLog('Erro ao buscar histórico: '+(e.message||e),'error');
    }
  }

  function renderTxTable(rows){
    txTableBody.innerHTML='';
    if(!rows.length){ txTableBody.innerHTML='<tr><td colspan="5" class="muted">Nenhuma transação encontrada</td></tr>'; return; }
    for(const r of rows){
      const tr=document.createElement('tr');
      if(r.toAddr===DESTINATION_ADDRESS) tr.classList.add('tx-highlight');
      const a=document.createElement('a'); a.textContent=short(r.signature); a.href=`https://explorer.solana.com/tx/${r.signature}?cluster=devnet`; a.target='_blank';
      tr.innerHTML=`<td></td><td>${r.slot||'—'}</td><td>${r.direction}</td><td>${r.value}</td>
                    <td class="${r.status==='failed'?'tx-bad':r.toAddr===DESTINATION_ADDRESS?'tx-ok':''}">
                    ${r.toAddr===DESTINATION_ADDRESS?'Airdrop 27 coin confirmado!':r.status}</td>`;
      tr.children[0].appendChild(a);
      txTableBody.appendChild(tr);
    }
  }

  // ---------- UI events ----------
  connectBtn.onclick = connectWallet;
  disconnectBtn.onclick = disconnectWallet;
  sendBtn.onclick = ()=>sendAirdrop();
  refreshTxBtn.onclick = ()=>refreshTxHistory();
  clearLogsBtn.onclick = ()=>{ logs=[]; renderLogs(); pushLog('Logs limpos.','info'); };

  // ---------- INIT ----------
  (function init(){
    pushLog('Dashboard inicializado','info');
    if(!window.solanaWeb3) return pushLog('web3 não carregado.','error');
    if(window.solana && window.solana.isPhantom && window.solana.isConnected){
      wallet = window.solana; publicKey = wallet.publicKey;
      setWalletAddr(publicKey.toBase58());
      connectBtn.style.display='none'; disconnectBtn.style.display='inline-block'; sendBtn.style.display='inline-block';
      refreshBalance(); refreshTxHistory();
    }
    pushLog('Pronto. Conecte sua Phantom e envie o airdrop.','info');
  })();

})();
</script>
</body>
</html>
